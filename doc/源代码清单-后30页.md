# WaveCast 源代码清单（后30页）

**著作权人：** 陈云亮  
**开发者：** 陈云亮  
**联系邮箱：** 676814828@qq.com  
**软件名称：** WaveCast  
**版本号：** 1.0.3  
**开发语言：** ArkTS  
**目标平台：** HarmonyOS API 12+  
**文档说明：** 本文档展示应用的核心源代码（后30页部分）

---

## 第1页：SettingsService.ets（第1-50行）

```typescript
import preferences from '@ohos.data.preferences';
import { ConfigurationConstant } from '@kit.AbilityKit';
import { AppSettings, ThemeMode } from '../model/AppSettings';
import { Constants } from '../common/Constants';

/**
 * 设置服务类
 * 管理应用的用户偏好设置，使用 Preferences 轻量级存储
 * 采用单例模式确保全局唯一实例
 */
export class SettingsService {
  private static instance: SettingsService;
  private preferences: preferences.Preferences | null = null;
  private settings: AppSettings = new AppSettings();
  private context: Context | null = null;

  private constructor() {}

  /**
   * 获取单例实例
   */
  static getInstance(): SettingsService {
    if (!SettingsService.instance) {
      SettingsService.instance = new SettingsService();
    }
    return SettingsService.instance;
  }

  /**
   * 初始化设置服务
   * @param context 应用上下文
   */
  async init(context: Context): Promise<void> {
    try {
      this.context = context;
      this.preferences = await preferences.getPreferences(context, Constants.PREF_SETTINGS);
      await this.loadSettings();
      // 初始化时应用主题
      this.applyTheme(this.settings.themeMode);
    } catch (error) {
      console.error('[SettingsService] Failed to initialize settings:', error);
    }
  }

  /**
   * 从 Preferences 加载所有设置
   */
  private async loadSettings(): Promise<void> {
    if (!this.preferences) return;

    try {
      // 加载主题设置
```

---

## 第2页：SettingsService.ets（第51-100行）

```typescript
      const theme = await this.preferences.get(Constants.PREF_THEME, ThemeMode.AUTO);
      this.settings.themeMode = theme as ThemeMode;

      // 加载播放速度
      const speed = await this.preferences.get(Constants.PREF_PLAYBACK_SPEED, 1.0);
      this.settings.playbackSpeed = speed as number;

      // 加载网络设置
      const wifiOnly = await this.preferences.get('wifi_only_download', true);
      this.settings.wifiOnlyDownload = wifiOnly as boolean;

      const autoDownload = await this.preferences.get('auto_download', false);
      this.settings.autoDownloadNewEpisodes = autoDownload as boolean;

      // 加载播放设置
      const skipSilence = await this.preferences.get('skip_silence', false);
      this.settings.skipSilence = skipSilence as boolean;

      const keepEpisodes = await this.preferences.get('keep_last_n_episodes', 20);
      this.settings.keepLastNEpisodes = keepEpisodes as number;

      const continuePlayback = await this.preferences.get('continue_playback', true);
      this.settings.continuePlayback = continuePlayback as boolean;

      const autoDeletePlayed = await this.preferences.get('auto_delete_played', false);
      this.settings.autoDeletePlayed = autoDeletePlayed as boolean;

      // 加载通知设置
      const enableNotifications = await this.preferences.get('enable_notifications', true);
      this.settings.enableNotifications = enableNotifications as boolean;

      const notifyNewEpisodes = await this.preferences.get('notify_new_episodes', true);
      this.settings.notifyNewEpisodes = notifyNewEpisodes as boolean;

    } catch (error) {
      console.error('Failed to load settings:', error);
    }
  }

  /**
   * 保存所有设置到 Preferences
   */
  private async saveSettings(): Promise<void> {
    if (!this.preferences) return;

    try {
      await this.preferences.put(Constants.PREF_THEME, this.settings.themeMode);
      await this.preferences.put(Constants.PREF_PLAYBACK_SPEED, this.settings.playbackSpeed);
      await this.preferences.put('wifi_only_download', this.settings.wifiOnlyDownload);
```

---

## 第3页：SettingsService.ets（第101-150行）

```typescript
      await this.preferences.put('auto_download', this.settings.autoDownloadNewEpisodes);
      await this.preferences.put('skip_silence', this.settings.skipSilence);
      await this.preferences.put('keep_last_n_episodes', this.settings.keepLastNEpisodes);
      await this.preferences.put('continue_playback', this.settings.continuePlayback);
      await this.preferences.put('auto_delete_played', this.settings.autoDeletePlayed);
      await this.preferences.put('enable_notifications', this.settings.enableNotifications);
      await this.preferences.put('notify_new_episodes', this.settings.notifyNewEpisodes);

      // 持久化到磁盘
      await this.preferences.flush();
    } catch (error) {
      console.error('Failed to save settings:', error);
    }
  }

  /**
   * 应用主题
   * @param mode 主题模式
   */
  private applyTheme(mode: ThemeMode): void {
    if (!this.context) return;

    try {
      let colorMode: ConfigurationConstant.ColorMode;
      switch (mode) {
        case ThemeMode.LIGHT:
          colorMode = ConfigurationConstant.ColorMode.COLOR_MODE_LIGHT;
          break;
        case ThemeMode.DARK:
          colorMode = ConfigurationConstant.ColorMode.COLOR_MODE_DARK;
          break;
        case ThemeMode.AUTO:
        default:
          colorMode = ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET;
          break;
      }
      console.info(`[SettingsService] Theme applied: ${mode}`);
    } catch (error) {
      console.error('[SettingsService] Failed to apply theme:', error);
    }
  }

  // ===== 主题设置 =====

  /**
   * 设置主题模式
   */
  async setThemeMode(mode: ThemeMode): Promise<void> {
    this.settings.themeMode = mode;
    this.applyTheme(mode);
```

---

## 第4页：SettingsService.ets（第151-200行）

```typescript
    await this.saveSettings();
  }

  getThemeMode(): ThemeMode {
    return this.settings.themeMode;
  }

  // ===== 网络设置 =====

  /**
   * 设置是否仅WiFi下载
   */
  async setWifiOnlyDownload(enabled: boolean): Promise<void> {
    this.settings.wifiOnlyDownload = enabled;
    await this.saveSettings();
  }

  getWifiOnlyDownload(): boolean {
    return this.settings.wifiOnlyDownload;
  }

  /**
   * 设置是否自动下载新单集
   */
  async setAutoDownloadNewEpisodes(enabled: boolean): Promise<void> {
    this.settings.autoDownloadNewEpisodes = enabled;
    await this.saveSettings();
  }

  getAutoDownloadNewEpisodes(): boolean {
    return this.settings.autoDownloadNewEpisodes;
  }

  // ===== 播放设置 =====

  /**
   * 设置播放速度
   * @param speed 播放速度（0.5 - 3.0）
   */
  async setPlaybackSpeed(speed: number): Promise<void> {
    this.settings.playbackSpeed = speed;
    await this.saveSettings();
    console.info(`[SettingsService] Playback speed set to ${speed}`);
  }

  getPlaybackSpeed(): number {
    return this.settings.playbackSpeed;
  }

  /**
```

---

## 第5页：SettingsService.ets（第201-261行）

```typescript
   * 设置是否跳过静音
   */
  async setSkipSilence(enabled: boolean): Promise<void> {
    this.settings.skipSilence = enabled;
    await this.saveSettings();
  }

  getSkipSilence(): boolean {
    return this.settings.skipSilence;
  }

  /**
   * 设置是否自动续播
   */
  async setContinuePlayback(enabled: boolean): Promise<void> {
    this.settings.continuePlayback = enabled;
    await this.saveSettings();
  }

  getContinuePlayback(): boolean {
    return this.settings.continuePlayback;
  }

  // ===== 存储设置 =====

  /**
   * 设置是否自动删除已播放单集
   */
  async setAutoDeletePlayed(enabled: boolean): Promise<void> {
    this.settings.autoDeletePlayed = enabled;
    await this.saveSettings();
  }

  getAutoDeletePlayed(): boolean {
    return this.settings.autoDeletePlayed;
  }

  /**
   * 设置保留最近N集
   */
  async setKeepLastNEpisodes(count: number): Promise<void> {
    this.settings.keepLastNEpisodes = count;
    await this.saveSettings();
  }

  getKeepLastNEpisodes(): number {
    return this.settings.keepLastNEpisodes;
  }

  // ===== 通知设置 =====

  /**
   * 设置是否启用通知
   */
  async setEnableNotifications(enabled: boolean): Promise<void> {
    this.settings.enableNotifications = enabled;
    await this.saveSettings();
  }

  getEnableNotifications(): boolean {
    return this.settings.enableNotifications;
  }
}
```

---

## 第6页：DatabaseService.ets（第1-50行）

```typescript
import relationalStore from '@ohos.data.relationalStore';
import { Podcast } from '../model/Podcast';
import { Episode } from '../model/Episode';
import { QueueItem } from '../model/QueueItem';
import { Constants } from '../common/Constants';

/**
 * 搜索结果类
 * 包含搜索到的单集列表和总数
 */
export class EpisodeSearchResult {
  episodes: Episode[] = [];
  total: number = 0;

  constructor(episodes: Episode[], total: number) {
    this.episodes = episodes;
    this.total = total;
  }
}

/**
 * 数据库版本历史
 * 每次修改数据库结构时，需要：
 * 1. 在 Constants.DB_VERSION 中增加版本号
 * 2. 在 migrateDatabase() 中添加对应的迁移逻辑
 * 
 * 版本历史:
 * - v1: 初始版本，创建 podcast, episode, queue 表
 * - v2: 添加 podcast 表的 isFetchFailed 和 lastSuccessfulFetch 字段
 */

/**
 * 数据库服务类
 * 基于 SQLite (relationalStore) 实现
 * 支持版本管理和自动数据迁移
 */
export class DatabaseService {
  private static instance: DatabaseService;
  private rdbStore: relationalStore.RdbStore | null = null;

  private constructor() {}

  /**
   * 获取单例实例
   */
  static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
```

---

## 第7页：DatabaseService.ets（第51-100行）

```typescript
  }

  /**
   * 初始化数据库
   * @param context 应用上下文
   */
  async init(context: Context): Promise<void> {
    try {
      const config: relationalStore.StoreConfig = {
        name: Constants.DB_NAME,
        securityLevel: relationalStore.SecurityLevel.S1
      };

      this.rdbStore = await relationalStore.getRdbStore(context, config);
      
      // 检查并执行数据库迁移
      await this.checkAndMigrateDatabase();
      
      console.info(`[DatabaseService] Database initialized, version: ${Constants.DB_VERSION}`);
    } catch (error) {
      console.error('Failed to initialize database:', error);
    }
  }

  /**
   * 检查并执行数据库迁移
   */
  private async checkAndMigrateDatabase(): Promise<void> {
    if (!this.rdbStore) return;

    try {
      // 获取当前数据库版本
      const currentVersion = await this.getDatabaseVersion();
      const targetVersion = Constants.DB_VERSION;

      console.info(`[DatabaseService] Current DB version: ${currentVersion}, Target: ${targetVersion}`);

      if (currentVersion === 0) {
        // 新安装，创建所有表
        await this.createTables();
        await this.setDatabaseVersion(targetVersion);
        console.info('[DatabaseService] Fresh install, tables created');
      } else if (currentVersion < targetVersion) {
        // 需要升级
        await this.migrateDatabase(currentVersion, targetVersion);
        await this.setDatabaseVersion(targetVersion);
        console.info(`[DatabaseService] Migration completed: v${currentVersion} -> v${targetVersion}`);
      } else {
        console.info('[DatabaseService] Database is up to date');
      }
    } catch (error) {
```

---

## 第8页：DatabaseService.ets（第101-150行）

```typescript
      console.error('[DatabaseService] Migration failed:', error);
      // 迁移失败时尝试创建表（容错处理）
      await this.createTables();
    }
  }

  /**
   * 获取数据库版本
   */
  private async getDatabaseVersion(): Promise<number> {
    if (!this.rdbStore) return 0;

    try {
      // 尝试从系统表读取版本
      const sql = `SELECT name FROM sqlite_master WHERE type='table' AND name='db_version'`;
      const resultSet = await this.rdbStore.querySql(sql);
      
      if (resultSet.rowCount === 0) {
        resultSet.close();
        return 0;
      }
      resultSet.close();

      // 读取版本号
      const versionSql = `SELECT version FROM db_version LIMIT 1`;
      const versionResult = await this.rdbStore.querySql(versionSql);
      
      if (versionResult.rowCount === 0) {
        versionResult.close();
        return 0;
      }

      versionResult.goToFirstRow();
      const version = versionResult.getLong(0);
      versionResult.close();
      
      return version;
    } catch (error) {
      console.error('[DatabaseService] Failed to get DB version:', error);
      return 0;
    }
  }

  /**
   * 设置数据库版本
   */
  private async setDatabaseVersion(version: number): Promise<void> {
    if (!this.rdbStore) return;

    try {
      // 确保版本表存在
      await this.rdbStore.executeSql(`
        CREATE TABLE IF NOT EXISTS db_version (
```

---

## 第9页：DatabaseService.ets（第151-200行）

```typescript
          id INTEGER PRIMARY KEY,
          version INTEGER NOT NULL
        )
      `);

      // 删除旧版本记录
      await this.rdbStore.executeSql(`DELETE FROM db_version`);
      
      // 插入新版本
      await this.rdbStore.executeSql(`INSERT INTO db_version (id, version) VALUES (1, ${version})`);
      
      console.info(`[DatabaseService] Database version set to ${version}`);
    } catch (error) {
      console.error('[DatabaseService] Failed to set DB version:', error);
    }
  }

  /**
   * 创建所有数据表
   */
  private async createTables(): Promise<void> {
    if (!this.rdbStore) return;

    try {
      // 创建播客表
      await this.rdbStore.executeSql(`
        CREATE TABLE IF NOT EXISTS ${Constants.TABLE_PODCAST} (
          id TEXT PRIMARY KEY,
          title TEXT NOT NULL,
          author TEXT,
          description TEXT,
          imageUrl TEXT,
          feedUrl TEXT NOT NULL,
          link TEXT,
          language TEXT,
          category TEXT,
          subscribeDate INTEGER,
          lastUpdate INTEGER,
          episodeCount INTEGER DEFAULT 0,
          isSubscribed INTEGER DEFAULT 1,
          isFetchFailed INTEGER DEFAULT 0,
          lastSuccessfulFetch INTEGER DEFAULT 0
        )
      `);

      // 创建单集表
      await this.rdbStore.executeSql(`
        CREATE TABLE IF NOT EXISTS ${Constants.TABLE_EPISODE} (
          id TEXT PRIMARY KEY,
          podcastId TEXT NOT NULL,
          title TEXT NOT NULL,
```

---

## 第10页：DatabaseService.ets（第201-250行）

```typescript
          description TEXT,
          link TEXT,
          audioUrl TEXT,
          imageUrl TEXT,
          duration INTEGER DEFAULT 0,
          fileSize INTEGER DEFAULT 0,
          pubDate INTEGER,
          downloadStatus INTEGER DEFAULT 0,
          downloadProgress INTEGER DEFAULT 0,
          localPath TEXT,
          playbackPosition INTEGER DEFAULT 0,
          isPlayed INTEGER DEFAULT 0,
          isFavorite INTEGER DEFAULT 0,
          addedToQueueDate INTEGER DEFAULT 0,
          FOREIGN KEY (podcastId) REFERENCES ${Constants.TABLE_PODCAST}(id) ON DELETE CASCADE
        )
      `);

      // 创建队列表
      await this.rdbStore.executeSql(`
        CREATE TABLE IF NOT EXISTS ${Constants.TABLE_QUEUE} (
          id TEXT PRIMARY KEY,
          episodeId TEXT NOT NULL,
          position INTEGER NOT NULL,
          addedDate INTEGER,
          FOREIGN KEY (episodeId) REFERENCES ${Constants.TABLE_EPISODE}(id) ON DELETE CASCADE
        )
      `);

      // 创建索引优化查询
      await this.rdbStore.executeSql(`
        CREATE INDEX IF NOT EXISTS idx_episode_podcast ON ${Constants.TABLE_EPISODE}(podcastId)
      `);
      await this.rdbStore.executeSql(`
        CREATE INDEX IF NOT EXISTS idx_episode_pubdate ON ${Constants.TABLE_EPISODE}(pubDate DESC)
      `);
      await this.rdbStore.executeSql(`
        CREATE INDEX IF NOT EXISTS idx_queue_position ON ${Constants.TABLE_QUEUE}(position)
      `);

      console.info('[DatabaseService] All tables created successfully');
    } catch (error) {
      console.error('[DatabaseService] Failed to create tables:', error);
    }
  }

  /**
   * 执行数据库迁移
   * @param fromVersion 当前版本
   * @param toVersion 目标版本
   */
```

---

## 第11页：DatabaseService.ets（第251-300行）

```typescript
  private async migrateDatabase(fromVersion: number, toVersion: number): Promise<void> {
    if (!this.rdbStore) return;

    console.info(`[DatabaseService] Starting migration: v${fromVersion} -> v${toVersion}`);

    try {
      // 逐步升级
      for (let version = fromVersion; version < toVersion; version++) {
        await this.migrateToVersion(version + 1);
      }
    } catch (error) {
      console.error('[DatabaseService] Migration failed:', error);
      throw error;
    }
  }

  /**
   * 迁移到指定版本
   * @param version 目标版本号
   */
  private async migrateToVersion(version: number): Promise<void> {
    if (!this.rdbStore) return;

    console.info(`[DatabaseService] Migrating to version ${version}`);

    switch (version) {
      case 2:
        // v2: 添加播客失败标记字段
        try {
          await this.rdbStore.executeSql(`
            ALTER TABLE ${Constants.TABLE_PODCAST} ADD COLUMN isFetchFailed INTEGER DEFAULT 0
          `);
          await this.rdbStore.executeSql(`
            ALTER TABLE ${Constants.TABLE_PODCAST} ADD COLUMN lastSuccessfulFetch INTEGER DEFAULT 0
          `);
          console.info('[DatabaseService] Migrated to v2: Added fetch status fields');
        } catch (error) {
          console.warn('[DatabaseService] v2 migration error (may already exist):', error);
        }
        break;
      
      default:
        console.warn(`[DatabaseService] No migration defined for version ${version}`);
    }
  }

  // ===== 播客相关操作 =====

  /**
   * 保存播客
   */
```

---

## 第12页：DatabaseService.ets（第301-350行）

```typescript
  async savePodcast(podcast: Podcast): Promise<void> {
    if (!this.rdbStore) return;

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        'id': podcast.id,
        'title': podcast.title,
        'author': podcast.author,
        'description': podcast.description,
        'imageUrl': podcast.imageUrl,
        'feedUrl': podcast.feedUrl,
        'link': podcast.link,
        'language': podcast.language,
        'category': podcast.category,
        'subscribeDate': podcast.subscribeDate,
        'lastUpdate': podcast.lastUpdate,
        'episodeCount': podcast.episodeCount,
        'isSubscribed': podcast.isSubscribed ? 1 : 0,
        'isFetchFailed': podcast.isFetchFailed ? 1 : 0,
        'lastSuccessfulFetch': podcast.lastSuccessfulFetch
      };

      await this.rdbStore.insert(Constants.TABLE_PODCAST, valueBucket, relationalStore.ConflictResolution.ON_CONFLICT_REPLACE);
    } catch (error) {
      console.error('[DatabaseService] Failed to save podcast:', error);
    }
  }

  /**
   * 获取播客列表
   */
  async getPodcasts(): Promise<Podcast[]> {
    if (!this.rdbStore) return [];

    try {
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_PODCAST);
      predicates.equalTo('isSubscribed', 1);
      predicates.orderByDesc('subscribeDate');
      
      const resultSet = await this.rdbStore.query(predicates);
      const podcasts: Podcast[] = [];

      while (resultSet.goToNextRow()) {
        const podcast = new Podcast();
        podcast.id = resultSet.getString(resultSet.getColumnIndex('id'));
        podcast.title = resultSet.getString(resultSet.getColumnIndex('title'));
        podcast.author = resultSet.getString(resultSet.getColumnIndex('author'));
        podcast.description = resultSet.getString(resultSet.getColumnIndex('description'));
        podcast.imageUrl = resultSet.getString(resultSet.getColumnIndex('imageUrl'));
```

---

## 第13页：DatabaseService.ets（第351-400行）

```typescript
        podcast.feedUrl = resultSet.getString(resultSet.getColumnIndex('feedUrl'));
        podcast.link = resultSet.getString(resultSet.getColumnIndex('link'));
        podcast.language = resultSet.getString(resultSet.getColumnIndex('language'));
        podcast.category = resultSet.getString(resultSet.getColumnIndex('category'));
        podcast.subscribeDate = resultSet.getLong(resultSet.getColumnIndex('subscribeDate'));
        podcast.lastUpdate = resultSet.getLong(resultSet.getColumnIndex('lastUpdate'));
        podcast.episodeCount = resultSet.getLong(resultSet.getColumnIndex('episodeCount'));
        podcast.isSubscribed = resultSet.getLong(resultSet.getColumnIndex('isSubscribed')) === 1;
        podcast.isFetchFailed = resultSet.getLong(resultSet.getColumnIndex('isFetchFailed')) === 1;
        podcast.lastSuccessfulFetch = resultSet.getLong(resultSet.getColumnIndex('lastSuccessfulFetch'));
        podcasts.push(podcast);
      }

      resultSet.close();
      return podcasts;
    } catch (error) {
      console.error('[DatabaseService] Failed to get podcasts:', error);
      return [];
    }
  }

  /**
   * 根据ID获取播客
   */
  async getPodcastById(id: string): Promise<Podcast | null> {
    if (!this.rdbStore) return null;

    try {
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_PODCAST);
      predicates.equalTo('id', id);
      
      const resultSet = await this.rdbStore.query(predicates);

      if (resultSet.rowCount === 0) {
        resultSet.close();
        return null;
      }

      resultSet.goToFirstRow();
      const podcast = new Podcast();
      podcast.id = resultSet.getString(resultSet.getColumnIndex('id'));
      podcast.title = resultSet.getString(resultSet.getColumnIndex('title'));
      podcast.author = resultSet.getString(resultSet.getColumnIndex('author'));
      podcast.description = resultSet.getString(resultSet.getColumnIndex('description'));
      podcast.imageUrl = resultSet.getString(resultSet.getColumnIndex('imageUrl'));
      podcast.feedUrl = resultSet.getString(resultSet.getColumnIndex('feedUrl'));
      podcast.link = resultSet.getString(resultSet.getColumnIndex('link'));
      podcast.language = resultSet.getString(resultSet.getColumnIndex('language'));
      podcast.category = resultSet.getString(resultSet.getColumnIndex('category'));
```

---

## 第14页：DatabaseService.ets（第401-450行）

```typescript
      podcast.subscribeDate = resultSet.getLong(resultSet.getColumnIndex('subscribeDate'));
      podcast.lastUpdate = resultSet.getLong(resultSet.getColumnIndex('lastUpdate'));
      podcast.episodeCount = resultSet.getLong(resultSet.getColumnIndex('episodeCount'));
      podcast.isSubscribed = resultSet.getLong(resultSet.getColumnIndex('isSubscribed')) === 1;
      podcast.isFetchFailed = resultSet.getLong(resultSet.getColumnIndex('isFetchFailed')) === 1;
      podcast.lastSuccessfulFetch = resultSet.getLong(resultSet.getColumnIndex('lastSuccessfulFetch'));

      resultSet.close();
      return podcast;
    } catch (error) {
      console.error('[DatabaseService] Failed to get podcast by id:', error);
      return null;
    }
  }

  /**
   * 删除播客及其所有单集
   */
  async deletePodcast(podcastId: string): Promise<void> {
    if (!this.rdbStore) return;

    try {
      // 先删除所有单集
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.equalTo('podcastId', podcastId);
      await this.rdbStore.delete(predicates);

      // 再删除播客
      const podcastPredicates = new relationalStore.RdbPredicates(Constants.TABLE_PODCAST);
      podcastPredicates.equalTo('id', podcastId);
      await this.rdbStore.delete(podcastPredicates);

      console.info(`[DatabaseService] Deleted podcast: ${podcastId}`);
    } catch (error) {
      console.error('[DatabaseService] Failed to delete podcast:', error);
    }
  }

  // ===== 单集相关操作 =====

  /**
   * 保存单集
   */
  async saveEpisode(episode: Episode): Promise<void> {
    if (!this.rdbStore) return;

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        'id': episode.id,
```

---

## 第15页：DatabaseService.ets（第451-500行）

```typescript
        'podcastId': episode.podcastId,
        'title': episode.title,
        'description': episode.description,
        'link': episode.link,
        'audioUrl': episode.audioUrl,
        'imageUrl': episode.imageUrl,
        'duration': episode.duration,
        'fileSize': episode.fileSize,
        'pubDate': episode.pubDate,
        'downloadStatus': episode.downloadStatus,
        'downloadProgress': episode.downloadProgress,
        'localPath': episode.localPath,
        'playbackPosition': episode.playbackPosition,
        'isPlayed': episode.isPlayed ? 1 : 0,
        'isFavorite': episode.isFavorite ? 1 : 0,
        'addedToQueueDate': episode.addedToQueueDate
      };

      await this.rdbStore.insert(Constants.TABLE_EPISODE, valueBucket, relationalStore.ConflictResolution.ON_CONFLICT_REPLACE);
    } catch (error) {
      console.error('[DatabaseService] Failed to save episode:', error);
    }
  }

  /**
   * 批量保存单集（提升性能）
   */
  async saveEpisodes(episodes: Episode[]): Promise<void> {
    if (!this.rdbStore || episodes.length === 0) return;

    try {
      // 使用事务批量插入
      await this.rdbStore.beginTransaction();
      
      for (const episode of episodes) {
        const valueBucket: relationalStore.ValuesBucket = {
          'id': episode.id,
          'podcastId': episode.podcastId,
          'title': episode.title,
          'description': episode.description,
          'link': episode.link,
          'audioUrl': episode.audioUrl,
          'imageUrl': episode.imageUrl,
          'duration': episode.duration,
          'fileSize': episode.fileSize,
          'pubDate': episode.pubDate,
          'downloadStatus': episode.downloadStatus,
          'downloadProgress': episode.downloadProgress,
          'localPath': episode.localPath,
          'playbackPosition': episode.playbackPosition,
```

---

## 第16页：DatabaseService.ets（第501-550行）

```typescript
          'isPlayed': episode.isPlayed ? 1 : 0,
          'isFavorite': episode.isFavorite ? 1 : 0,
          'addedToQueueDate': episode.addedToQueueDate
        };

        await this.rdbStore.insert(Constants.TABLE_EPISODE, valueBucket, relationalStore.ConflictResolution.ON_CONFLICT_REPLACE);
      }

      await this.rdbStore.commit();
      console.info(`[DatabaseService] Saved ${episodes.length} episodes in batch`);
    } catch (error) {
      console.error('[DatabaseService] Failed to save episodes in batch:', error);
      await this.rdbStore?.rollback();
    }
  }

  /**
   * 获取所有单集
   */
  async getAllEpisodes(): Promise<Episode[]> {
    if (!this.rdbStore) return [];

    try {
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.orderByDesc('pubDate');
      
      const resultSet = await this.rdbStore.query(predicates);
      const episodes: Episode[] = [];

      while (resultSet.goToNextRow()) {
        episodes.push(this.parseEpisodeFromResultSet(resultSet));
      }

      resultSet.close();
      return episodes;
    } catch (error) {
      console.error('[DatabaseService] Failed to get all episodes:', error);
      return [];
    }
  }

  /**
   * 根据播客ID获取单集列表
   */
  async getEpisodesByPodcastId(podcastId: string): Promise<Episode[]> {
    if (!this.rdbStore) return [];

    try {
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.equalTo('podcastId', podcastId);
```

---

## 第17页：DatabaseService.ets（第551-600行）

```typescript
      predicates.orderByDesc('pubDate');
      
      const resultSet = await this.rdbStore.query(predicates);
      const episodes: Episode[] = [];

      while (resultSet.goToNextRow()) {
        episodes.push(this.parseEpisodeFromResultSet(resultSet));
      }

      resultSet.close();
      return episodes;
    } catch (error) {
      console.error('[DatabaseService] Failed to get episodes by podcast id:', error);
      return [];
    }
  }

  /**
   * 根据ID获取单集
   */
  async getEpisodeById(id: string): Promise<Episode | null> {
    if (!this.rdbStore) return null;

    try {
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.equalTo('id', id);
      
      const resultSet = await this.rdbStore.query(predicates);

      if (resultSet.rowCount === 0) {
        resultSet.close();
        return null;
      }

      resultSet.goToFirstRow();
      const episode = this.parseEpisodeFromResultSet(resultSet);

      resultSet.close();
      return episode;
    } catch (error) {
      console.error('[DatabaseService] Failed to get episode by id:', error);
      return null;
    }
  }

  /**
   * 搜索单集
   * @param keyword 搜索关键词
   * @param offset 偏移量
   * @param limit 限制数量
   */
  async searchEpisodes(keyword: string, offset: number, limit: number): Promise<EpisodeSearchResult> {
```

---

## 第18页：DatabaseService.ets（第601-650行）

```typescript
    if (!this.rdbStore) return new EpisodeSearchResult([], 0);

    try {
      // 先查询总数
      const countSql = `
        SELECT COUNT(*) as total FROM ${Constants.TABLE_EPISODE}
        WHERE title LIKE ? OR description LIKE ?
      `;
      const countResult = await this.rdbStore.querySql(countSql, [`%${keyword}%`, `%${keyword}%`]);
      countResult.goToFirstRow();
      const total = countResult.getLong(0);
      countResult.close();

      // 再查询分页数据
      const dataSql = `
        SELECT * FROM ${Constants.TABLE_EPISODE}
        WHERE title LIKE ? OR description LIKE ?
        ORDER BY pubDate DESC
        LIMIT ? OFFSET ?
      `;
      const resultSet = await this.rdbStore.querySql(dataSql, [`%${keyword}%`, `%${keyword}%`, limit, offset]);
      const episodes: Episode[] = [];

      while (resultSet.goToNextRow()) {
        episodes.push(this.parseEpisodeFromResultSet(resultSet));
      }

      resultSet.close();
      return new EpisodeSearchResult(episodes, total);
    } catch (error) {
      console.error('[DatabaseService] Failed to search episodes:', error);
      return new EpisodeSearchResult([], 0);
    }
  }

  /**
   * 标记单集为已播放
   */
  async markEpisodeAsPlayed(episodeId: string): Promise<void> {
    if (!this.rdbStore) return;

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        'isPlayed': 1
      };

      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.equalTo('id', episodeId);

      await this.rdbStore.update(valueBucket, predicates);
```

---

## 第19页：DatabaseService.ets（第651-700行）

```typescript
      console.info(`[DatabaseService] Marked episode as played: ${episodeId}`);
    } catch (error) {
      console.error('[DatabaseService] Failed to mark episode as played:', error);
    }
  }

  /**
   * 更新单集播放进度
   */
  async updateEpisodeProgress(episodeId: string, position: number): Promise<void> {
    if (!this.rdbStore) return;

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        'playbackPosition': position
      };

      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.equalTo('id', episodeId);

      await this.rdbStore.update(valueBucket, predicates);
    } catch (error) {
      console.error('[DatabaseService] Failed to update episode progress:', error);
    }
  }

  /**
   * 更新单集下载状态
   */
  async updateEpisodeDownloadStatus(
    episodeId: string, 
    status: number, 
    progress: number, 
    localPath?: string
  ): Promise<void> {
    if (!this.rdbStore) return;

    try {
      const valueBucket: relationalStore.ValuesBucket = {
        'downloadStatus': status,
        'downloadProgress': progress
      };

      if (localPath) {
        valueBucket['localPath'] = localPath;
      }

      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_EPISODE);
      predicates.equalTo('id', episodeId);

      await this.rdbStore.update(valueBucket, predicates);
```

---

## 第20页：DatabaseService.ets（第701-750行）

```typescript
    } catch (error) {
      console.error('[DatabaseService] Failed to update download status:', error);
    }
  }

  /**
   * 从 ResultSet 解析单集对象
   */
  private parseEpisodeFromResultSet(resultSet: relationalStore.ResultSet): Episode {
    const episode = new Episode();
    episode.id = resultSet.getString(resultSet.getColumnIndex('id'));
    episode.podcastId = resultSet.getString(resultSet.getColumnIndex('podcastId'));
    episode.title = resultSet.getString(resultSet.getColumnIndex('title'));
    episode.description = resultSet.getString(resultSet.getColumnIndex('description'));
    episode.link = resultSet.getString(resultSet.getColumnIndex('link'));
    episode.audioUrl = resultSet.getString(resultSet.getColumnIndex('audioUrl'));
    episode.imageUrl = resultSet.getString(resultSet.getColumnIndex('imageUrl'));
    episode.duration = resultSet.getLong(resultSet.getColumnIndex('duration'));
    episode.fileSize = resultSet.getLong(resultSet.getColumnIndex('fileSize'));
    episode.pubDate = resultSet.getLong(resultSet.getColumnIndex('pubDate'));
    episode.downloadStatus = resultSet.getLong(resultSet.getColumnIndex('downloadStatus'));
    episode.downloadProgress = resultSet.getLong(resultSet.getColumnIndex('downloadProgress'));
    episode.localPath = resultSet.getString(resultSet.getColumnIndex('localPath'));
    episode.playbackPosition = resultSet.getLong(resultSet.getColumnIndex('playbackPosition'));
    episode.isPlayed = resultSet.getLong(resultSet.getColumnIndex('isPlayed')) === 1;
    episode.isFavorite = resultSet.getLong(resultSet.getColumnIndex('isFavorite')) === 1;
    episode.addedToQueueDate = resultSet.getLong(resultSet.getColumnIndex('addedToQueueDate'));
    return episode;
  }

  // ===== 队列相关操作 =====

  /**
   * 添加到队列
   */
  async addToQueue(episodeId: string): Promise<void> {
    if (!this.rdbStore) return;

    try {
      // 获取当前最大位置
      const sql = `SELECT MAX(position) as maxPos FROM ${Constants.TABLE_QUEUE}`;
      const resultSet = await this.rdbStore.querySql(sql);
      
      let maxPosition = 0;
      if (resultSet.rowCount > 0) {
        resultSet.goToFirstRow();
        maxPosition = resultSet.getLong(0);
      }
      resultSet.close();

      // 插入新队列项
```

---

## 第21页：DatabaseService.ets（第751-790行）+ 配置总结

```typescript
      const queueItem = new QueueItem();
      queueItem.id = Date.now().toString();
      queueItem.episodeId = episodeId;
      queueItem.position = maxPosition + 1;
      queueItem.addedDate = Date.now();

      const valueBucket: relationalStore.ValuesBucket = {
        'id': queueItem.id,
        'episodeId': queueItem.episodeId,
        'position': queueItem.position,
        'addedDate': queueItem.addedDate
      };

      await this.rdbStore.insert(Constants.TABLE_QUEUE, valueBucket);
      console.info(`[DatabaseService] Added to queue: ${episodeId}`);
    } catch (error) {
      console.error('[DatabaseService] Failed to add to queue:', error);
    }
  }

  /**
   * 从队列移除
   */
  async removeFromQueue(episodeId: string): Promise<void> {
    if (!this.rdbStore) return;

    try {
      const predicates = new relationalStore.RdbPredicates(Constants.TABLE_QUEUE);
      predicates.equalTo('episodeId', episodeId);
      
      await this.rdbStore.delete(predicates);
      console.info(`[DatabaseService] Removed from queue: ${episodeId}`);
    } catch (error) {
      console.error('[DatabaseService] Failed to remove from queue:', error);
    }
  }

  /**
   * 清空队列
   */
  async clearQueue(): Promise<void> {
    if (!this.rdbStore) return;

    try {
      await this.rdbStore.executeSql(`DELETE FROM ${Constants.TABLE_QUEUE}`);
      console.info('[DatabaseService] Queue cleared');
    } catch (error) {
      console.error('[DatabaseService] Failed to clear queue:', error);
    }
  }
}
```

---

## 第22-25页：资源配置文件

### 第22页：string.json 字符串资源

```json
{
  "string": [
    {
      "name": "app_name",
      "value": "WaveCast"
    },
    {
      "name": "app_description",
      "value": "HarmonyOS 播客管理应用"
    },
    {
      "name": "module_desc",
      "value": "应用主模块"
    },
    {
      "name": "EntryAbility_desc",
      "value": "应用入口"
    },
    {
      "name": "EntryAbility_label",
      "value": "WaveCast"
    },
    {
      "name": "permission_internet_reason",
      "value": "用于获取播客内容和下载音频文件"
    },
    {
      "name": "permission_network_info_reason",
      "value": "用于检测网络连接状态"
    },
    {
      "name": "permission_background_reason",
      "value": "用于支持后台播放音频"
    }
  ]
}
```

### 第23页：color.json 颜色资源

```json
{
  "color": [
    {
      "name": "start_window_background",
      "value": "#FFFFFF"
    },
    {
      "name": "background_light",
      "value": "#F5F5F5"
    },
    {
      "name": "text_primary_light",
      "value": "#1F1F1F"
    },
    {
      "name": "text_secondary_light",
      "value": "#757575"
    },
    {
      "name": "primary_color",
      "value": "#5C6BC0"
    },
    {
      "name": "accent_color",
      "value": "#FF5252"
    }
  ]
}
```

### 第24页：main_pages.json 路由配置

```json
{
  "src": [
    "pages/MainPage",
    "pages/PlayerPage",
    "pages/SearchPage",
    "pages/PodcastDetailPage",
    "pages/EpisodeDetailPage",
    "pages/QueuePage",
    "pages/DownloadPage",
    "pages/SettingsPage",
    "pages/SubscriptionPage"
  ]
}
```

### 第25页：package.json 依赖配置

```json
{
  "name": "antennaPodHM",
  "version": "1.0.3",
  "description": "HarmonyOS Podcast Manager",
  "main": "index.js",
  "author": "陈云亮",
  "license": "Apache-2.0",
  "dependencies": {
    "@ohos/hypium": "1.0.18"
  }
}
```

---

## 第26-30页：核心特性实现总结

### 第26页：播放速度记忆机制

**实现要点：**

1. **SettingsService 存储**
   - 使用 Preferences 持久化播放速度
   - 键名：`playback_speed`
   - 默认值：1.0

2. **PlayerService 同步**
   - 初始化时从 SettingsService 加载
   - `setPlaybackSpeed()` 时同步保存
   - `resume()` 时重新应用速度

3. **PlayerPage UI 同步**
   - `aboutToAppear()` 从 PlayerService 获取
   - 选择速度时同时更新两个服务

**代码流程：**
```
用户选择速度
  ↓
PlayerPage.showSpeedSelectorMenu()
  ↓
PlayerService.setPlaybackSpeed()  → AVPlayer.setSpeed()
  ↓
SettingsService.setPlaybackSpeed() → Preferences.put()
  ↓
持久化到磁盘
```

---

### 第27页：后台播放实现

**技术方案：**

1. **后台任务管理**
   - 使用 `backgroundTaskManager`
   - 类型：`AUDIO_PLAYBACK`
   - 在播放开始时启动

2. **AVSession 集成**
   - 创建音频会话
   - 注册媒体控制回调
   - 更新播放状态和元数据

3. **生命周期管理**
   - `onForeground()` - 前台恢复
   - `onBackground()` - 后台继续
   - `onDestroy()` - 释放资源

**权限要求：**
- `ohos.permission.KEEP_BACKGROUND_RUNNING`

---

### 第28页：下载管理架构

**DownloadService 核心功能：**

1. **下载任务管理**
   - 支持多任务并发
   - 断点续传
   - 进度监控

2. **存储管理**
   - 文件保存路径：`podcasts/`
   - 文件命名：`{episodeId}.mp3`
   - 数据库记录同步

3. **网络策略**
   - WiFi only 模式
   - 自动重试机制
   - 超时处理

4. **状态同步**
   - 实时更新数据库
   - 通知 UI 刷新
   - 下载完成回调

---

### 第29页：数据库架构设计

**三张核心表：**

1. **podcast 表**
   - 存储播客基本信息
   - 刷新策略字段
   - 订阅状态管理

2. **episode 表**
   - 存储单集详细信息
   - 播放进度记录
   - 下载状态跟踪

3. **queue 表**
   - 播放队列管理
   - 位置排序
   - 时间戳记录

**索引优化：**
- `idx_episode_podcast` - 加速播客查询
- `idx_episode_pubdate` - 优化时间排序
- `idx_queue_position` - 队列排序

**版本管理：**
- 自动检测版本
- 增量迁移
- 向后兼容

---

### 第30页：应用架构总结

**分层架构：**

```
┌─────────────────────────────────────┐
│          Presentation Layer         │
│    (Pages: MainPage, PlayerPage)    │
├─────────────────────────────────────┤
│         Business Logic Layer        │
│  (Services: Player, Database, etc)  │
├─────────────────────────────────────┤
│          Data Access Layer          │
│   (Models: Podcast, Episode, etc)   │
├─────────────────────────────────────┤
│         Platform Services Layer     │
│  (HarmonyOS APIs: Media, Network)   │
└─────────────────────────────────────┘
```

**核心设计模式：**
- **单例模式** - Service 层
- **观察者模式** - 事件监听
- **工厂模式** - Model 创建
- **策略模式** - 网络下载

**关键技术点：**
1. 播放速度全局同步机制
2. 后台播放AVSession集成
3. 数据库版本自动迁移
4. 下载任务断点续传
5. 播放进度实时保存
6. 队列自动续播逻辑

**性能优化：**
- 批量数据库操作
- 图片缓存管理
- 异步加载策略
- 内存占用控制

---

**文档说明：**
本文档展示了 WaveCast 应用的核心源代码（后30页部分），重点包括设置服务、数据库服务、配置文件和核心特性实现总结。这些代码与前30页共同构成了应用的完整实现。

**版权信息：**
- 软件名称：WaveCast
- 版本：1.0.3
- 著作权人：陈云亮
- 开发者：陈云亮
- 联系邮箱：676814828@qq.com
- 包名：com.pangpang.wavecast
- 开源许可：Apache-2.0

---
